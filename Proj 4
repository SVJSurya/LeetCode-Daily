import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split

# --- 0. Data Creation (Synthetic Dataset) ---
# In a real-world scenario, you would load this from a CSV file.
# e.g., df = pd.read_csv('employee_data.csv')
print("--- Step 0: Creating Synthetic Data ---")
data = {
    'Age': np.random.randint(22, 60, 1000),
    'Gender': np.random.choice(['Male', 'Female'], 1000),
    'Education Level': np.random.choice(['High School', 'Bachelor\'s', 'Master\'s', 'PhD'], 1000),
    'Job Title': np.random.choice(['Software Engineer', 'Data Scientist', 'Project Manager', 'HR Specialist', 'Marketing Manager', 'Sales Associate', 'Graphic Designer', 'Accountant'], 1000),
    'Years of Experience': np.random.uniform(0, 35, 1000).round(1),
    'Salary': np.nan # We will generate this based on other features
}
df = pd.DataFrame(data)

# Generate salary based on other features to make it realistic
base_salary = {
    'High School': 40000, "Bachelor's": 60000, "Master's": 80000, 'PhD': 100000
}
job_multiplier = {
    'Software Engineer': 1.2, 'Data Scientist': 1.5, 'Project Manager': 1.3,
    'HR Specialist': 0.9, 'Marketing Manager': 1.1, 'Sales Associate': 0.8,
    'Graphic Designer': 0.95, 'Accountant': 1.0
}

df['Salary'] = df.apply(
    lambda row: (base_salary[row['Education Level']] +
                 job_multiplier[row['Job Title']] * row['Years of Experience'] * 1500 +
                 row['Age'] * 200 +
                 np.random.normal(0, 10000)),
    axis=1
).round(0)

# Introduce some missing values for demonstration
for col in ['Age', 'Years of Experience']:
    df.loc[df.sample(frac=0.05).index, col] = np.nan

print("Data created successfully.")
print("Initial DataFrame head:")
print(df.head())
print("\n" + "="*50 + "\n")


# --- 1. Data Preprocessing ---
print("--- Step 1: Data Preprocessing ---")
# Check for missing values
print("Missing values before handling:")
print(df.isnull().sum())

# Handle missing values using imputation (filling with the median)
# Median is often better for skewed data like salary or experience
df['Age'].fillna(df['Age'].median(), inplace=True)
df['Years of Experience'].fillna(df['Years of Experience'].median(), inplace=True)

print("\nMissing values after handling:")
print(df.isnull().sum())

# Check data types
print("\nData types:")
print(df.info())
print("\n" + "="*50 + "\n")


# --- 2. Exploratory Data Analysis (EDA) ---
print("--- Step 2: Exploratory Data Analysis (EDA) ---")
# Set plot style
sns.set_style('whitegrid')

# a. Distribution of continuous variables
plt.figure(figsize=(18, 5))
plt.subplot(1, 3, 1)
sns.histplot(df['Age'], kde=True, color='blue').set_title('Age Distribution')
plt.subplot(1, 3, 2)
sns.histplot(df['Years of Experience'], kde=True, color='green').set_title('Experience Distribution')
plt.subplot(1, 3, 3)
sns.histplot(df['Salary'], kde=True, color='red').set_title('Salary Distribution')
plt.suptitle('Distribution of Continuous Variables', fontsize=16)
plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

# b. Distribution of Gender and Education Level
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
sns.countplot(data=df, x='Gender', palette='viridis').set_title('Gender Distribution')
plt.subplot(1, 2, 2)
sns.countplot(data=df, y='Education Level', palette='plasma').set_title('Education Level Distribution')
plt.suptitle('Distribution of Categorical Variables', fontsize=16)
plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

# c. Top 10 highest paying job titles
# Note: With 8 job titles, this will show all of them.
mean_salary_by_job = df.groupby('Job Title')['Salary'].mean().sort_values(ascending=False).head(10)
plt.figure(figsize=(10, 6))
sns.barplot(x=mean_salary_by_job.values, y=mean_salary_by_job.index, palette='coolwarm')
plt.title('Top 10 Highest Paying Job Titles')
plt.xlabel('Mean Salary')
plt.ylabel('Job Title')
plt.show()

# d. Relationships between Experience/Age and Salary
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
sns.scatterplot(data=df, x='Years of Experience', y='Salary', alpha=0.5)
plt.title('Experience vs. Salary')
plt.subplot(1, 2, 2)
sns.scatterplot(data=df, x='Age', y='Salary', alpha=0.5)
plt.title('Age vs. Salary')
plt.suptitle('Relationships with Salary', fontsize=16)
plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

# e. Impact of Job Title and Education on Salary
plt.figure(figsize=(14, 6))
sns.boxplot(data=df, x='Salary', y='Education Level', palette='muted')
plt.title('Impact of Education Level on Salary')
plt.show()

# f. Correlation matrix for numerical features
numerical_df = df[['Age', 'Years of Experience', 'Salary']]
correlation_matrix = numerical_df.corr()
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='viridis', fmt='.2f')
plt.title('Correlation Matrix of Numerical Features')
plt.show()

print("EDA plots have been generated.")
print("\n" + "="*50 + "\n")


# --- 3. Feature Engineering ---
print("--- Step 3: Feature Engineering ---")

# a. Encode categorical data using One-Hot Encoding
# One-Hot Encoding is preferred for nominal data as it doesn't create an artificial order.
categorical_cols = ['Gender', 'Education Level', 'Job Title']
df_encoded = pd.get_dummies(df, columns=categorical_cols, drop_first=True)

print("DataFrame head after One-Hot Encoding:")
print(df_encoded.head())

# b. Normalize numeric features
# We scale Age and Years of Experience so they are on a similar scale.
scaler = MinMaxScaler()
numeric_cols = ['Age', 'Years of Experience']
df_encoded[numeric_cols] = scaler.fit_transform(df_encoded[numeric_cols])

print("\nDataFrame head after Normalizing Numeric Features:")
print(df_encoded.head())

print("\nData is now preprocessed and ready for model training.")
