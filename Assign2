"""
World Happiness Report 2019 Analysis using NumPy
This script processes and analyzes the 2019 World Happiness Report data
using NumPy for efficient numerical computations.
"""

import numpy as np
import time
from timeit import default_timer as timer

def load_and_validate_data(filename='2019.csv'):
    """Load and validate the happiness report data."""
    try:
        # Load data using numpy's genfromtxt to handle CSV
        # Skip header row (1) and use comma delimiter
        data = np.genfromtxt(filename, delimiter=',', skip_header=1, 
                            dtype=None, encoding='utf-8', missing_values='',
                            filling_values=np.nan)
        
        print(f"\nData loaded successfully from {filename}")
        print(f"Shape: {data.shape}")
        print(f"Size: {data.size}")
        print(f"Data type: {data.dtype}")
        
        return data
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found in current directory.")
        return None
    except Exception as e:
        print(f"Error loading data: {str(e)}")
        return None

def extract_numeric_columns(data):
    """Extract numeric columns from the dataset."""
    try:
        # Assuming columns are in this order in the CSV
        score = data['Score'].astype(float)
        gdp = data['GDP per capita'].astype(float)
        health = data['Healthy life expectancy'].astype(float)
        freedom = data['Freedom to make life choices'].astype(float)
        
        return score, gdp, health, freedom
    except Exception as e:
        print(f"Error extracting columns: {str(e)}")
        return None, None, None, None

def compute_basic_stats(score):
    """Compute basic statistics for the Score column."""
    return {
        'mean': np.mean(score),
        'median': np.median(score),
        'std': np.std(score)
    }

def find_gdp_extremes(data, gdp):
    """Find countries with min/max GDP."""
    min_idx = np.argmin(gdp)
    max_idx = np.argmax(gdp)
    return {
        'min_country': data['Country or region'][min_idx],
        'min_gdp': gdp[min_idx],
        'max_country': data['Country or region'][max_idx],
        'max_gdp': gdp[max_idx]
    }

def filter_happy_countries(data, score, threshold=7.0):
    """Filter countries with score above threshold."""
    happy_mask = score > threshold
    return data[happy_mask]

def find_top_health_countries(data, health, n=5):
    """Find top N countries by health expectancy."""
    top_indices = np.argsort(health)[-n:][::-1]
    return data['Country or region'][top_indices], health[top_indices]

def sort_by_freedom(data, freedom):
    """Sort countries by freedom score."""
    sorted_indices = np.argsort(freedom)[::-1]
    return data[sorted_indices][:10]

def compute_correlation(gdp, score):
    """Compute correlation between GDP and Score."""
    return np.corrcoef(gdp, score)[0, 1]

def normalize_column(column):
    """Normalize column to 0-1 range."""
    min_val = np.min(column)
    max_val = np.max(column)
    return (column - min_val) / (max_val - min_val)

def categorize_happiness(data, score):
    """Group countries by happiness level and compute mean GDP."""
    high_mask = score >= 7.0
    medium_mask = (score >= 5.0) & (score < 7.0)
    low_mask = score < 5.0
    
    categories = {
        'high': data[high_mask],
        'medium': data[medium_mask],
        'low': data[low_mask]
    }
    return categories

def main():
    # Part 1: Data Loading and Preprocessing
    data = load_and_validate_data()
    if data is None:
        return
    
    # Extract numeric columns
    score, gdp, health, freedom = extract_numeric_columns(data)
    if score is None:
        return
    
    # Part 2: Basic Operations
    stats = compute_basic_stats(score)
    print("\nScore Statistics:")
    print(f"Mean: {stats['mean']:.3f}")
    print(f"Median: {stats['median']:.3f}")
    print(f"Standard Deviation: {stats['std']:.3f}")
    
    gdp_extremes = find_gdp_extremes(data, gdp)
    print("\nGDP Extremes:")
    print(f"Lowest GDP: {gdp_extremes['min_country']} ({gdp_extremes['min_gdp']:.3f})")
    print(f"Highest GDP: {gdp_extremes['max_country']} ({gdp_extremes['max_gdp']:.3f})")
    
    # Part 3: Filtering and Sorting
    happy_countries = filter_happy_countries(data, score)
    print("\nCountries with Score > 7.0:")
    for country in happy_countries['Country or region']:
        print(country)
    
    top_health_countries, top_health_values = find_top_health_countries(data, health)
    print("\nTop 5 Countries by Health Expectancy:")
    for country, value in zip(top_health_countries, top_health_values):
        print(f"{country}: {value:.3f}")
    
    # Freedom sorting
    top_freedom = sort_by_freedom(data, freedom)
    print("\nTop 10 Countries by Freedom Score:")
    for country, f_score in zip(top_freedom['Country or region'], top_freedom['Freedom to make life choices']):
        print(f"{country}: {f_score:.3f}")
    
    # Part 4: Advanced Calculations
    correlation = compute_correlation(gdp, score)
    print(f"\nCorrelation between GDP and Score: {correlation:.3f}")
    
    normalized_health = normalize_column(health)
    print("\nFirst 10 Normalized Health Values:")
    for country, value in zip(data['Country or region'][:10], normalized_health[:10]):
        print(f"{country}: {value:.3f}")
    
    # Categorize countries
    categories = categorize_happiness(data, score)
    for category, cat_data in categories.items():
        mean_gdp = np.mean(cat_data['GDP per capita'])
        print(f"\n{category.title()} Happiness Category (n={len(cat_data)}):")
        print(f"Mean GDP: {mean_gdp:.3f}")
    
    # Part 5: Save and Verify Data
    try:
        # Add normalized health to data and save
        output_data = np.column_stack((data, normalized_health))
        np.savetxt('Happiness_Normalized.csv', output_data, delimiter=',',
                   fmt='%s', header='Original data,Normalized Health')
        print("\nData saved to Happiness_Normalized.csv")
        
        # Verify saved data
        loaded_data = np.genfromtxt('Happiness_Normalized.csv', delimiter=',', skip_header=1)
        print(f"\nVerification - Loaded data shape: {loaded_data.shape}")
    except Exception as e:
        print(f"Error saving/loading data: {str(e)}")
    
    # Part 6: Performance Comparison
    def python_loop():
        return [s * s for s in score]
    
    def numpy_vectorized():
        return np.square(score)
    
    # Time comparison
    n_iterations = 1000
    
    python_time = timer()
    for _ in range(n_iterations):
        python_loop()
    python_time = timer() - python_time
    
    numpy_time = timer()
    for _ in range(n_iterations):
        numpy_vectorized()
    numpy_time = timer() - numpy_time
    
    print(f"\nPerformance Comparison ({n_iterations} iterations):")
    print(f"Python loop time: {python_time:.6f} seconds")
    print(f"NumPy vectorized time: {numpy_time:.6f} seconds")
    print(f"Speed improvement: {python_time/numpy_time:.1f}x faster with NumPy")

if __name__ == "__main__":
    main()
